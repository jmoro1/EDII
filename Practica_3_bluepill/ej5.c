typedef int            int32_t;
typedef short          int16_t;
typedef char           int8_t;
typedef unsigned int   uint32_t;
typedef unsigned short uint16_t;
typedef unsigned char  uint8_t;

//RCC AND APB2ENR ADRESS AND OFFSET
#define RCC_BASE_ADDRESS ((uint32_t) 0x40021000) //RESET AND CLOCK CONTROL BASE ADDRESS
#define RCC_APB2ENR_OFFSET ((uint32_t) 0x18) //PERIPHERAL CLOCK ENABLE REGISTER OFFSET
#define APB2ENR_GPIOC_ENA_BIT 4 //BIT 4 TIENE QUE ESTAR EN 1 PARA DARLE ENABLE AL CLOCK DEL GPIOC
#define APB2ENR_GPIOB_ENA_BIT 3 //BIT 4 TIENE QUE ESTAR EN 1 PARA DARLE ENABLE AL CLOCK DEL GPIOB


//GPIOC AND GPIOB, CRH AND ODR BASE ADDRESS AND OFFSETS
#define GPIOC_BASE_ADDRESS ((uint32_t) 0x40011000) // GPIOC BASE ADDRESS
#define GPIOB_BASE_ADDRESS ((uint32_t) 0x40010C00) // GPIOB BASE ADDRESS
#define GPIO_CRL_OFFSET ((uint32_t) 0x00) // CONFIGURATION REGISTER LOW (0-7) OFFSET
#define GPIO_CRH_OFFSET ((uint32_t) 0x04) // CONFIGURATION REGISTER HIGH (8-15) OFFSET
#define GPIO_ODR_OFFSET ((uint32_t) 0x0C) // OUTPUT DATA REGISTER OFFSET
#define GPIO_IDR_OFFSET ((uint32_t) 0x08) // INPUT DATA REGISTER OFFSET



//DEFINICIONES DE BITS PARA CONFIG DEL PC13 COMO OUTPUT
#define PC13_MODE_BIT0 20
#define PC13_MODE_BIT1 21
#define PC13_CNF_BIT0 22
#define PC13_CNF_BIT1 23
#define PC13_ODR_BIT 13     

//SYSTICK ADDRESS
#define SYSTICK_BASE_ADDRESS ((uint32_t) 0xE000E010)
#define CSR_ENA_BIT 0
#define CSR_TICKINT_BIT 1
#define CSR_CLKSRC_BIT 2
#define CSR_COUNTFLAG_BIT 16



typedef struct{ //DECLARO UNA STRUCT PARA ACCEDER A LOS REGISTROS DEL SYSTICK
    volatile uint32_t SYST_CSR; //CONTROL AND STATUS REGISTER (SHOULD BE 0xE000E010)
    volatile uint32_t SYST_RVR; //RELOAD VALUE REGISTER (SHOULD BE 0xE000E014 ) 
    volatile uint32_t SYST_CVR;//CURRENT VALUE REGISTER (SHOULD BE 0xE000E018 )
    volatile const uint32_t SYST_CALIB;//CALIBRATION VALUE REGISTER (SHOULD BE 0xE000E01C )

}SysTick_Type;   

//PUNTERO A LA STRUCT SYSTICK
#define SysTick ((SysTick_Type *) SYSTICK_BASE_ADDRESS)


int main(void)
{
    //CALCULO LAS DIRECCIONES DEL APB2ENR, CRH Y ODR
    volatile uint32_t *pAPB2ENR = (uint32_t *)(RCC_BASE_ADDRESS + RCC_APB2ENR_OFFSET);
    volatile uint32_t *pCRH = (uint32_t *)(GPIOC_BASE_ADDRESS + GPIO_CRH_OFFSET);
    volatile uint32_t *pODR = (uint32_t *)(GPIOC_BASE_ADDRESS + GPIO_ODR_OFFSET);  

    *pAPB2ENR |= (0x1 << APB2ENR_GPIOC_ENA_BIT); //DOY ENABLE AL CLOCK DEL GPIOC
    
    /*
    *pCRH |= (0x1 << PC13_MODE_BIT0); 
    *pCRH |= (0x0 << PC13_MODE_BIT1); //SETEO EL MODE DEL CRH CON 01 MODO OUTPUT MAX 10MHz
    *pCRH |= (0x0 << PC13_CNF_BIT0); 
    *pCRH |= (0x0 << PC13_CNF_BIT1); // SETEO EL CNF DEL CRH CON 00 GENERAL PURPOSE OUTPUT PUSH-PULL
    //*pODR |= (0x0 << PC13_ODR_BIT); //PONGO EN 0 EL BIT DEL ODR (OUTPUT DATA)
    */  
    *pCRH |= ((0x1 << PC13_MODE_BIT0) | (0x0 << PC13_MODE_BIT1) | (0x0 << PC13_CNF_BIT0) | (0x0 << PC13_CNF_BIT1)); // LO DE ARRIBA EN UNA LINEA


    //EXTRAIGO LOS ULTIMOS 24 BITS DEL REGISTRO DE CALIBRACION (TENMS)
    uint32_t CalibrationValue_10ms = SysTick->SYST_CALIB & 0x00FFFFFF; //RELOAD VALUE PARA 10ms
    uint32_t CalibrationValue_1s = CalibrationValue_10ms * 100; //modifico el reload value para tener un tiempo de 1000ms
    //BORRO LOS ULTIMOS 24 BITS DEL REGISTRO DE RELOAD VALUE
    uint32_t LoadCurrentValue = SysTick->SYST_RVR & 0xFF000000;
    //ARMO LA PALABRA USANDO LOS PRIMEROS 8 BITS DEL RVR Y LOS 24 DEL TENMS DEL CALIB Y LOS ASIGNO AL RVR
    SysTick->SYST_RVR = CalibrationValue_1s | LoadCurrentValue; //1째 SETEO EL RELOAD VALUE
    SysTick->SYST_CVR |= (0x1 << 0) ; //2째 - ESCRIBO UN 1 EN EL PRIMER BIT DEL REGISTRO CURRENT VALUE PARA LIMPIARLO
    //AHORA SI 3째 SETEO EL CONTROL AND STATUS REGISTER CSR, INCLUYENDO ENABLE
    /* ENFOQUE TRADICIONAL PARA SETEAR EL CSR
    SysTick->SYST_CSR |= (0x1 << CSR_ENA_BIT);  // DOY ENABLE AL SYSTICK   
    SysTick->SYST_CSR |= (0x1 << CSR_TICKINT_BIT); // DOY ENABLE A LA INTERRUPCION
    SysTick->SYST_CSR |= (0x0 << CSR_CLKSRC_BIT); //SETEO EL CLOCK COMO EXTERNO
    */

    SysTick->SYST_CSR |= ((0x1 << CSR_ENA_BIT) | (0x1 << CSR_TICKINT_BIT) | (0x0 << CSR_CLKSRC_BIT) ) // OTRA FORMA DE HACER LO DE ARRIBA EN UNA LINEA
    //4째HAGO ESTO EN ESTE ORDEN PORQUE ASI LO DICE LA USER GUIDE DEL CORTEX-M3



	for(;;){
        if((SysTick->SYST_CSR & CSR_COUNTFLAG_BIT) != 0 ){ //VEO SI EL BIT 16 DEL CSR ESTA EN 1
            *pODR |= (0x0 << PC13_ODR_BIT); //PONGO EN 0 EL BIT DEL ODR (OUTPUT DATA)    
        }else{
            *pODR |= (0x1 << PC13_ODR_BIT); //PONGO EN 1 EL BIT DEL ODR (OUTPUT DATA)   

        }
    }

	return 0;
}

#define SRAM_SIZE ((uint32_t) 0x00005000)
#define SRAM_BASE ((uint32_t) 0x20000000)
#define STACKINIT ((interrupt_t)(SRAM_BASE+SRAM_SIZE))

typedef void(*interrupt_t)(void);
const interrupt_t vector_table[256] __attribute__ ((section(".vtab"))) = {
	STACKINIT,												// 0x0000_0000 Stack Pointer
	(interrupt_t) main,										// 0x0000_0004 Reset
};